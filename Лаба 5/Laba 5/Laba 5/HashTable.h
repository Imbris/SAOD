#pragma once
#include <iostream>
using namespace std;

/// <summary>
/// Шаблонный класс для узлов Хэш-Таблицы
/// TKey - тип для ключа
/// TValue - тип для значения
/// </summary>
template<class TKey, class TValue>
class HashTableNodePair
{
private:
	TKey key;
	TValue value;
	bool isVoid; // Указывает - удален ли элемент
public:
	HashTableNodePair()
	{
		this->isVoid = true;
	}

	/// <summary>
	/// Инициализирует новый элемент в хэш-таблице
	/// </summary>
	/// <param name="key">Ключ в хэш-таблице</param>
	/// <param name="value">Значение соответствующее данному ключу</param>
	HashTableNodePair(TKey key, TValue value)
	{
		this->key = key;
		this->value = value;
		this->isVoid = false;
	}

	TValue GetValue() {
		return value;
	}

	TKey GetKey() {
		return key;
	}

	bool GetIsVoid() {
		return this->isVoid;
	}

	void SetValue(TValue value) {
		this->value = value;
	}

	void SetIsVoid(bool value) {
		this->isVoid = value;
	}
};

/// <summary>
/// Шаблонный класс Хэш-Таблицы
/// TKey - тип для ключа
/// TValue - тип для значения
/// </summary>
template<class TKey, class TValue>
class HashTable
{
protected:

	/// <summary>
	/// Массив узлов хэш-таблицы
	/// </summary>
	HashTableNodePair<TKey, TValue> *mass;

	/// <summary>
	/// Размер хэш-таблицы
	/// </summary>
	int size;

	/// <summary>
	/// Кол-во непустых клеток в таблице
	/// </summary>
	int count_not_void;

	/// <summary>
	/// Хэщ-функция
	/// </summary>
	/// <param name="key">Ключ элемента из хэш-таблицы</param>
	/// <param name="attempt">Номер попытки</param>
	/// <returns></returns>
	virtual int GetIndex(TKey key, int attempt) = 0;
public:

	/// <summary>
	/// Инициализирует хэш-таблицу с заданным размером
	/// </summary>
	/// <param name="size">Размер хэш-таблицы</param>
	HashTable<TKey, TValue>(int size)
	{
		this->size = size;
		this->count_not_void = size;
		mass = new HashTableNodePair<TKey, TValue>[size];
	}

	HashTableNodePair<TKey, TValue>* GetMass()
	{
		return this->mass;
	}

	/// <summary>
	/// Возвращает кол-во пустых клеток в хэш-таблицы
	/// </summary>
	/// <returns></returns>
	int GetVoidCount() 
	{
		return this->count_not_void;
	}

	/// <summary>
	/// Добавляет новый элемент в хэш таблицу
	/// </summary>
	/// <param name="key">Ключ элемента из хэш-таблицы</param>
	/// <param name="value">Значение соответствующее данному ключу</param>
	void Add(TKey key, TValue value)
	{
		// Если указанного элемента нет в таблице
		if (this->FindNode(key) == -1)
		{
			int attempt = 0; // кол-во попыток добавить новый элемент
			int index; // индекс для нового элемента
			HashTableNodePair<TKey, TValue> *node = 0; // Новый элемент на добавление в таблицу
			do
			{
				index = this->GetIndex(key, attempt);
				node = &this->mass[index];
				attempt++;
			} while (node && node->GetIsVoid() == false && attempt != size); // пока существует по заданному ключу элемент
		
			if ( (node && node->GetIsVoid()) || !node) { // Если по заданному ключу - элемент удален
				this->mass[index] = HashTableNodePair<TKey, TValue>(key, value);
				this->count_not_void--;
			}
			else {
				throw exception("Таблица заполнена");
			}
		}
		else {
			throw exception("Элемент с указанным ключем и значением уже существует");
		}
	}

	/// <summary>
	/// Удаляет элемент из таблицы с заданным ключом и значением
	/// </summary>
	/// <param name="key">Ключ элемента из хэш-таблицы</param>
	/// <returns></returns>
	bool Remove(TKey key) 
	{
		// Если в таблице есть элементы
		if (size)
		{
			int index = this->FindNode(key); 

			// Если нашелся элемент с заданным ключем и значением в таблице
			if (index != -1)
			{
				this->mass[index].SetIsVoid(true); // Помечаем его удаленным
			}
			else {
				throw exception("Элемента с указанным ключем и значением - нет в таблице");
			}
		}
	}

	/// <summary>
	/// Возвращает индекс элемента с заданным ключем и значением в массиве хэш-таблицы
	/// или -1 в случаи если такой элемент не нашелся
	/// </summary>
	/// <param name="key">Ключ элемента из хэш-таблицы</param>
	/// <returns></returns>
	virtual int FindNode(TKey key) = 0;
};